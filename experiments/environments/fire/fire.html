<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hollywood Studio Quality Fire</title>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
            background: #000;
        }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 100, 0, 0.5);
            color: white;
            padding: 20px;
            border-radius: 12px;
            min-width: 250px;
            z-index: 100;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(255, 50, 0, 0.4);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        .control-group {
            margin-bottom: 16px;
        }
        label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }
        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 100, 0, 0.3);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            margin: 0;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff4500, #dc143c);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(255, 69, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        .value {
            color: #ff6b35;
            font-weight: 600;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 11px;
        }
        h3 {
            margin: 0 0 16px 0;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            text-align: center;
            color: #ff6b35;
        }
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 11px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>ðŸ”¥ Hollywood Fire Studio</h3>
        <div class="control-group">
            <label>Fire Intensity: <span class="value" id="intensityValue">2.0</span></label>
            <input type="range" id="intensity" min="0.5" max="5.0" step="0.1" value="2.0">
        </div>
        <div class="control-group">
            <label>Flame Height: <span class="value" id="heightValue">3.0</span></label>
            <input type="range" id="height" min="1.0" max="8.0" step="0.1" value="3.0">
        </div>
        <div class="control-group">
            <label>Turbulence: <span class="value" id="turbulenceValue">1.2</span></label>
            <input type="range" id="turbulence" min="0.0" max="3.0" step="0.1" value="1.2">
        </div>
        <div class="control-group">
            <label>Wind Force: <span class="value" id="windValue">0.4</span></label>
            <input type="range" id="wind" min="0.0" max="2.0" step="0.05" value="0.4">
        </div>
        <div class="control-group">
            <label>Heat Distortion: <span class="value" id="heatValue">0.8</span></label>
            <input type="range" id="heat" min="0.0" max="2.0" step="0.1" value="0.8">
        </div>
        <div class="control-group">
            <label>Fire Spread: <span class="value" id="spreadValue">1.5</span></label>
            <input type="range" id="spread" min="0.5" max="3.0" step="0.1" value="1.5">
        </div>
        <div class="control-group">
            <label>Quality: <span class="value" id="qualityValue">High</span></label>
            <input type="range" id="quality" min="1" max="3" step="1" value="2">
        </div>
    </div>

            <div class="info">
            <strong>Hollywood Studio Fire</strong><br>
            Volumetric raymarching â€¢ Advanced noise â€¢ Realistic physics<br>
            Mouse: Orbit â€¢ Scroll: Zoom<br>
            <span id="fps">FPS: --</span>
        </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Scene setup with cinematic quality
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 10, 100);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 12);
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.5;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        // Post-processing for cinematic quality
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, // strength
            0.4, // radius
            0.85 // threshold
        );
        composer.addPass(bloomPass);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 50;

        // Advanced lighting setup
        const ambientLight = new THREE.AmbientLight(0x1a0a00, 0.1);
        scene.add(ambientLight);

        // Multiple fire lights for realism
        const fireLight1 = new THREE.PointLight(0xff4500, 3, 30);
        fireLight1.position.set(0, 0.5, 0); // Position at log level
        fireLight1.castShadow = true;
        fireLight1.shadow.mapSize.width = 512;
        fireLight1.shadow.mapSize.height = 512;
        scene.add(fireLight1);

        const fireLight2 = new THREE.PointLight(0xff6600, 2, 20);
        fireLight2.position.set(-0.5, 1.0, 0.5); // Lower position near logs
        fireLight2.castShadow = false; // Disable shadow for performance
        scene.add(fireLight2);

        const fireLight3 = new THREE.PointLight(0xffaa00, 1.5, 15);
        fireLight3.position.set(0.5, 1.5, -0.5); // Position above logs
        fireLight3.castShadow = false; // Disable shadow for performance
        scene.add(fireLight3);

        // Rim light for dramatic effect
        const rimLight = new THREE.DirectionalLight(0xff8844, 0.5);
        rimLight.position.set(-10, 10, -10);
        scene.add(rimLight);

        // Ground with realistic materials
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2a1810,
            roughness: 0.9,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Create advanced noise textures
        function createAdvancedNoiseTexture(size = 512) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(size, size);
            const data = imageData.data;
            
            // Advanced Perlin-like noise with multiple octaves
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 4;
                    
                    const nx = x / size;
                    const ny = y / size;
                    
                    let noise = 0;
                    let amplitude = 1;
                    let frequency = 1;
                    let maxValue = 0;
                    
                    // 5 octaves for optimized noise
                    for (let octave = 0; octave < 5; octave++) {
                        const sampleX = nx * frequency;
                        const sampleY = ny * frequency;
                        
                        const perlinValue = Math.sin(sampleX * Math.PI * 2) * Math.cos(sampleY * Math.PI * 2) +
                                          Math.sin(sampleX * Math.PI * 4 + Math.PI/3) * Math.cos(sampleY * Math.PI * 4 + Math.PI/3) * 0.5 +
                                          Math.sin(sampleX * Math.PI * 8 + Math.PI/6) * Math.cos(sampleY * Math.PI * 8 + Math.PI/6) * 0.25;
                        
                        noise += perlinValue * amplitude;
                        maxValue += amplitude;
                        amplitude *= 0.5;
                        frequency *= 2;
                    }
                    
                    noise = noise / maxValue;
                    const value = Math.floor((noise + 1) * 127.5);
                    
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value;
                    data[i + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            return texture;
        }

        // Create optimized noise textures
        const noiseTexture1 = createAdvancedNoiseTexture(256);
        const noiseTexture2 = createAdvancedNoiseTexture(128);
        const noiseTexture3 = createAdvancedNoiseTexture(64);

        // Hollywood-quality volumetric fire shader
        const fireVertexShader = `
            varying vec3 vPosition;
            varying vec3 vWorldPosition;
            varying vec3 vNormal;
            varying vec2 vUv;
            
            void main() {
                vPosition = position;
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                vNormal = normalize(normalMatrix * normal);
                vUv = uv;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fireFragmentShader = `
            precision highp float;
            
            uniform float time;
            uniform float intensity;
            uniform float height;
            uniform float turbulence;
            uniform float windSpeed;
            uniform float heatDistortion;
            uniform float fireSpread;
            uniform sampler2D noiseTexture1;
            uniform sampler2D noiseTexture2;
            uniform sampler2D noiseTexture3;
            
            varying vec3 vPosition;
            varying vec3 vWorldPosition;
            varying vec3 vNormal;
            varying vec2 vUv;
            
            // Advanced 3D noise using multiple 2D textures
            float noise3D(vec3 p) {
                vec2 uv1 = p.xy * 0.1 + p.z * 0.02;
                vec2 uv2 = p.xz * 0.08 + p.y * 0.03;
                vec2 uv3 = p.yz * 0.12 + p.x * 0.025;
                
                float n1 = texture2D(noiseTexture1, uv1 + time * 0.02).r;
                float n2 = texture2D(noiseTexture2, uv2 + time * 0.015).r;
                float n3 = texture2D(noiseTexture3, uv3 + time * 0.01).r;
                
                return (n1 * 0.5 + n2 * 0.3 + n3 * 0.2);
            }
            
            // Advanced Fractal Brownian Motion
            float fbm(vec3 p) {
                float value = 0.0;
                float amplitude = 0.5;
                float frequency = 1.0;
                
                // 4 octaves for balanced detail and performance
                for (int i = 0; i < 4; i++) {
                    value += amplitude * noise3D(p * frequency);
                    amplitude *= 0.5;
                    frequency *= 2.0;
                }
                
                return value;
            }
            
            // Enhanced realistic fire shape with improved physics
            float fireShape(vec3 p) {
                // Adjust position to start from ground level
                vec3 adjustedP = p;
                adjustedP.y = adjustedP.y + 3.0; // Offset to account for geometry positioning
                
                // Distance from center
                float dist = length(adjustedP.xz);
                
                // More realistic base shape - starts small at logs, expands upward
                float normalizedHeight = adjustedP.y / height;
                float baseRadius = fireSpread * (0.3 + normalizedHeight * 0.9 - normalizedHeight * normalizedHeight * 0.2);
                
                // Improved height-based falloff with natural fire curve
                float heightFactor = 1.0 - pow(normalizedHeight, 1.8);
                heightFactor = max(heightFactor, 0.0);
                
                // Ensure fire doesn't appear below ground level
                if (adjustedP.y < 0.0) return 0.0;
                
                // Enhanced turbulence with realistic fire behavior
                vec3 turbPos = adjustedP + vec3(windSpeed * time * 0.8, time * 2.5, windSpeed * time * 0.3);
                
                // Primary turbulence - main fire movement
                float turb1 = fbm(turbPos * 1.2) * turbulence;
                
                // Secondary turbulence - flame licking effects
                float turb2 = fbm(turbPos * 3.0 + vec3(50.0)) * turbulence * 0.4;
                
                float totalTurbulence = turb1 + turb2;
                
                // Enhanced wind effect with realistic physics
                float windEffect = windSpeed * pow(normalizedHeight, 0.8) * 2.5;
                vec3 windOffset = vec3(
                    windEffect * sin(time * 1.5 + adjustedP.y * 0.5), 
                    0.0, 
                    windEffect * cos(time * 1.2 + adjustedP.y * 0.3)
                );
                
                // Apply wind displacement
                vec3 windDisplaced = adjustedP + windOffset;
                float windDist = length(windDisplaced.xz);
                
                // Combine all effects with better blending
                float modifiedRadius = baseRadius + totalTurbulence * 0.6;
                float shape = 1.0 - smoothstep(0.0, modifiedRadius, windDist);
                
                // Apply height falloff
                shape *= heightFactor;
                
                // Enhanced density variation for more realistic flames
                float densityVar = 0.3 + totalTurbulence * 0.7 + sin(time * 3.0 + adjustedP.y * 2.0) * 0.2;
                shape *= densityVar;
                
                // Improved core fire region with better heat distribution - stronger at base
                float coreRadius = baseRadius * (0.6 - normalizedHeight * 0.3);
                float coreShape = 1.0 - smoothstep(0.0, coreRadius, dist);
                coreShape *= heightFactor * (2.0 - normalizedHeight * 0.5); // Stronger at base
                
                // Add flame tips - characteristic pointed flames
                float tipFactor = 1.0 + sin(time * 4.0 + dist * 10.0) * 0.3 * normalizedHeight;
                shape *= tipFactor;
                
                return max(shape, coreShape * 0.9);
            }
            
            // Advanced temperature calculation
            float getTemperature(vec3 p, float density) {
                float heightTemp = 1.0 - (p.y / height) * 0.7;
                
                // Core temperature boost
                float dist = length(p.xz);
                float coreBoost = exp(-dist * 2.0) * 0.5;
                
                // Noise-based temperature variation
                float tempNoise = fbm(p * 3.0 + time * 0.5) * 0.3;
                
                float temperature = heightTemp + coreBoost + tempNoise;
                temperature *= density; // Temperature correlates with density
                
                return clamp(temperature, 0.0, 1.0);
            }
            
            // Hollywood-quality fire colors
            vec3 getFireColor(float temperature, float density) {
                vec3 color;
                
                if (temperature > 0.9) {
                    // Ultra-hot core - white with blue tint
                    color = mix(vec3(1.0, 0.95, 0.8), vec3(0.9, 0.95, 1.0), (temperature - 0.9) * 10.0);
                } else if (temperature > 0.7) {
                    // Very hot - bright yellow/white
                    color = mix(vec3(1.0, 0.8, 0.2), vec3(1.0, 0.95, 0.8), (temperature - 0.7) * 5.0);
                } else if (temperature > 0.5) {
                    // Hot - yellow/orange
                    color = mix(vec3(1.0, 0.5, 0.1), vec3(1.0, 0.8, 0.2), (temperature - 0.5) * 5.0);
                } else if (temperature > 0.3) {
                    // Medium - orange/red
                    color = mix(vec3(1.0, 0.2, 0.0), vec3(1.0, 0.5, 0.1), (temperature - 0.3) * 5.0);
                } else if (temperature > 0.1) {
                    // Cool - red/dark red
                    color = mix(vec3(0.5, 0.1, 0.0), vec3(1.0, 0.2, 0.0), (temperature - 0.1) * 5.0);
                } else {
                    // Very cool - dark
                    color = vec3(0.1, 0.0, 0.0) * temperature * 10.0;
                }
                
                // Enhance brightness based on density
                color *= (0.5 + density * 1.5);
                
                return color;
            }
            
            void main() {
                // Ray setup for volumetric rendering
                vec3 rayStart = vWorldPosition;
                vec3 rayDir = normalize(rayStart - vec3(0.0, 3.0, 12.0));
                
                // Optimized raymarching with adaptive quality
                float stepSize = 0.08;
                int maxSteps = 40;
                
                vec3 finalColor = vec3(0.0);
                float totalAlpha = 0.0;
                
                // Optimized volumetric raymarching
                for (int i = 0; i < 40; i++) {
                    if (i >= maxSteps) break;
                    
                    vec3 currentPos = rayStart + rayDir * float(i) * stepSize;
                    
                    // Get fire density
                    float density = fireShape(currentPos) * intensity;
                    
                    if (density > 0.005) {
                        // Calculate temperature
                        float temperature = getTemperature(currentPos, density);
                        
                        // Get fire color
                        vec3 color = getFireColor(temperature, density);
                        
                        // Advanced alpha blending
                        float alpha = density * 0.08 * (1.0 + temperature * 0.5);
                        
                        // Accumulate color with proper volumetric integration
                        finalColor += color * alpha * (1.0 - totalAlpha);
                        totalAlpha += alpha * (1.0 - totalAlpha);
                        
                        // Early exit optimization
                        if (totalAlpha > 0.9) break;
                    }
                }
                
                // Add atmospheric glow
                float glow = 1.0 - length(vPosition.xz) / (fireSpread * 2.0);
                glow = pow(max(glow, 0.0), 2.0);
                finalColor += vec3(1.0, 0.4, 0.1) * glow * 0.15 * intensity;
                
                // Heat distortion effect
                vec2 distortion = vec2(
                    sin(time * 3.0 + vPosition.y * 2.0) * heatDistortion * 0.01,
                    cos(time * 2.5 + vPosition.x * 1.5) * heatDistortion * 0.01
                );
                
                // Apply heat shimmer to final color
                finalColor += vec3(0.1, 0.05, 0.0) * length(distortion) * 10.0;
                
                gl_FragColor = vec4(finalColor, totalAlpha);
            }
        `;

        // Create fire geometry that starts from the logs
        const fireGeometry = new THREE.CylinderGeometry(0.5, 2.5, 6, 64, 64);
        
        const fireMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                intensity: { value: 2.0 },
                height: { value: 3.0 },
                turbulence: { value: 1.2 },
                windSpeed: { value: 0.4 },
                heatDistortion: { value: 0.8 },
                fireSpread: { value: 1.5 },
                noiseTexture1: { value: noiseTexture1 },
                noiseTexture2: { value: noiseTexture2 },
                noiseTexture3: { value: noiseTexture3 }
            },
            vertexShader: fireVertexShader,
            fragmentShader: fireFragmentShader,
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const fire = new THREE.Mesh(fireGeometry, fireMaterial);
        fire.position.y = 0.3; // Start fire just above the logs
        scene.add(fire);

        // Add realistic logs and environment
        const logGeometry = new THREE.CylinderGeometry(0.15, 0.2, 3);
        const logMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3a2518,
            roughness: 0.9,
            metalness: 0.0
        });
        
        // Create log arrangement
        for (let i = 0; i < 5; i++) {
            const log = new THREE.Mesh(logGeometry, logMaterial);
            const angle = (i / 5) * Math.PI * 2;
            log.position.set(Math.cos(angle) * 0.8, 0.15, Math.sin(angle) * 0.8);
            log.rotation.z = Math.PI / 2;
            log.rotation.y = angle + Math.PI / 2;
            log.castShadow = true;
            scene.add(log);
        }

        // Add some rocks around the fire
        const rockGeometry = new THREE.DodecahedronGeometry(0.3);
        const rockMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x444444,
            roughness: 0.8,
            metalness: 0.1
        });
        
        for (let i = 0; i < 8; i++) {
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            const angle = (i / 8) * Math.PI * 2;
            const radius = 2 + Math.random() * 1;
            rock.position.set(Math.cos(angle) * radius, 0.15, Math.sin(angle) * radius);
            rock.scale.setScalar(0.5 + Math.random() * 0.5);
            rock.castShadow = true;
            scene.add(rock);
        }

        // Interactive controls
        document.getElementById('intensity').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            fireMaterial.uniforms.intensity.value = value;
            fireLight1.intensity = value * 1.5;
            fireLight2.intensity = value;
            fireLight3.intensity = value * 0.75;
            bloomPass.strength = value * 0.75;
            document.getElementById('intensityValue').textContent = value.toFixed(1);
        });

        document.getElementById('height').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            fireMaterial.uniforms.height.value = value;
            document.getElementById('heightValue').textContent = value.toFixed(1);
        });

        document.getElementById('turbulence').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            fireMaterial.uniforms.turbulence.value = value;
            document.getElementById('turbulenceValue').textContent = value.toFixed(1);
        });

        document.getElementById('wind').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            fireMaterial.uniforms.windSpeed.value = value;
            document.getElementById('windValue').textContent = value.toFixed(2);
        });

        document.getElementById('heat').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            fireMaterial.uniforms.heatDistortion.value = value;
            document.getElementById('heatValue').textContent = value.toFixed(1);
        });

        document.getElementById('spread').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            fireMaterial.uniforms.fireSpread.value = value;
            document.getElementById('spreadValue').textContent = value.toFixed(1);
        });

        // Quality control
        let qualitySettings = {
            1: { label: 'Low', pixelRatio: 1.0, bloomStrength: 0.8, shadowMapSize: 256 },
            2: { label: 'High', pixelRatio: 1.5, bloomStrength: 1.5, shadowMapSize: 512 },
            3: { label: 'Ultra', pixelRatio: 2.0, bloomStrength: 2.0, shadowMapSize: 1024 }
        };

        document.getElementById('quality').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            const settings = qualitySettings[value];
            
            document.getElementById('qualityValue').textContent = settings.label;
            
            // Update renderer settings
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, settings.pixelRatio));
            bloomPass.strength = settings.bloomStrength * fireMaterial.uniforms.intensity.value;
            
            // Update shadow map size
            fireLight1.shadow.mapSize.width = settings.shadowMapSize;
            fireLight1.shadow.mapSize.height = settings.shadowMapSize;
            fireLight1.shadow.needsUpdate = true;
        });

        // Performance monitoring and adaptive quality
        const clock = new THREE.Clock();
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;
        let adaptiveQuality = 1.0;

        function animate() {
            requestAnimationFrame(animate);
            
            const elapsedTime = clock.getElapsedTime();
            
            // FPS monitoring
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = currentTime;
                
                // Adaptive quality based on performance
                if (fps < 30) {
                    adaptiveQuality = Math.max(0.5, adaptiveQuality - 0.1);
                } else if (fps > 50) {
                    adaptiveQuality = Math.min(1.0, adaptiveQuality + 0.05);
                }
                
                // Update bloom strength based on performance
                bloomPass.strength = (1.5 * fireMaterial.uniforms.intensity.value * adaptiveQuality);
            }
            
            // Update fire shader
            fireMaterial.uniforms.time.value = elapsedTime;
            
            // Animate lights for realistic flickering
            fireLight1.intensity = (2 + Math.sin(elapsedTime * 12) * 0.5 + Math.sin(elapsedTime * 8) * 0.3) * fireMaterial.uniforms.intensity.value;
            fireLight2.intensity = (1.5 + Math.sin(elapsedTime * 10 + 1) * 0.4) * fireMaterial.uniforms.intensity.value;
            fireLight3.intensity = (1 + Math.sin(elapsedTime * 15 + 2) * 0.3) * fireMaterial.uniforms.intensity.value;
            
            // Dynamic light positions - now originating from logs
            fireLight1.position.x = Math.sin(elapsedTime * 2) * 0.2;
            fireLight1.position.z = Math.cos(elapsedTime * 1.5) * 0.2;
            fireLight1.position.y = 0.5 + Math.sin(elapsedTime * 3) * 0.3;
            
            fireLight2.position.x = -0.5 + Math.sin(elapsedTime * 2.5 + 1) * 0.3;
            fireLight2.position.y = 1.0 + Math.sin(elapsedTime * 4 + 1) * 0.4;
            
            fireLight3.position.x = 0.5 + Math.sin(elapsedTime * 1.8 + 2) * 0.3;
            fireLight3.position.y = 1.5 + Math.sin(elapsedTime * 3.5 + 2) * 0.3;
            
            controls.update();
            composer.render();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>